#单例模式

>单例模式有以下特点：
>1、单例类只能有一个实例。
>2、单例类必须自己创建自己的唯一实例。
>3、单例类必须给所有其他对象提供这一实例。
>单例模式确保某个类只有一个实例，而且自行实例化
>并向整个系统提供这个实例。在计算机系统中，
>线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象
>常被设计成单例。这些应用都或多或少具有资源管理器的功能。
>每台计算机可以有若干个打印机，但只能有一个Printer Spooler，
>以避免两个打印作业同时输出到打印机中。
>每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，
>以避免一个通信端口同时被两个请求同时调用。
>总之，选择单例模式就是为了避免不一致状态，避免政出多头。

>饿汉式和懒汉式区别
从名字上来说，饿汉和懒汉，
饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。
另外从以下两点再区分以下这两种方式：

>1、线程安全：
饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，
懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。


>2、资源加载和性能：
饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，
而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。
至于1、2、3这三种实现又有些区别，
第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，
第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗
第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。

这里的单例模式需要记住五种写法      
1.非线程安全的单例模式         
2.在getInstance方法上加同步  
3.双重检查锁定  
4.静态内部类  
5.饿汉式单例  

>饿汉模式的一些问题(存疑)
>synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。
到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？
首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）
其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。
再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。
最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！

